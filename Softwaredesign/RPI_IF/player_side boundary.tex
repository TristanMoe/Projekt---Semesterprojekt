\documentclass[Softwaredesign/Softwaredesign_main.tex]{subfiles}
\begin{document}


\section{playerside boudary}
På playerside siden skulle, der på psoc laves en boundary klasse, der stod for modtagelse af i2c beskeder fra raspberry pi. Der er to former for beskeder, der skal sendes til psoc'en på playerside. Det ene er status opdateringer, som er en byte lange. Mere detaljeret beskrivelse kan ses i grænseflade afsnittet \fullref{sec:RPi_Playerside_com}. Der bliver her brugt en i2c slave komponent i psoc creators komponent katalog. Denne komponent har en writebuffer, der selv opdatere efter hvert interrupt(der er en slaveInitReafbuffer funktion der tager et array af typen uint8, så det nu er dette array, der fungerer som bufferen). Der skal dog også læses fra denne buffer, når psoc'en modtager beskeden. Dette kan gøres på to forskellige måder. Den første måde er ved brug af polling og er den metode, der oftest bruges, hvis der ses i databladene. Dette kan dog i visse tilfælde ikke være optimalt, hvis programmet vil lave andet end blot at tjekke for i2c beskeder sendt. En anden mulighed er, at der læses fra writebufferen med det samme, når en besked bliver sendt. Dette kan lade sig gøre ved hjælp af interrupts. Som sagt så sker, der automatisk en opdatering af writebufferen ved brug af interrupts. Dette interrupt kan vi gå ind og gøre brug af ved hjælp af en callback metode I2C\_ISR\_EntryCallback(), som er fundet i i2c slave enhedens datasheet. Her vil funktionen RPi\_IF\_handleData() håndterer det der nu står i writebufferen. Spørgsmålet er, hvilken en af tingene, der er bedst. Vi har valgt polling af den grund at mange af de andre boundary klasser(CupLight\_IF og CupSensor\_IF) på PSoC'en bruger interrupts, og da der alligevel vil være et uendeligt for loop i programmet, hvor GameController klassens Controller er, så placeres funktionen RPi\_IF\_handleData() i denne funktion, så de andre boundaries prioriteres over denne klasse, når der sker et interrupt. Der vil dog stadig være de interrupts, der høre til i2c slave enheden på PSoC'en og som sørger for at opdaterer writebufferen hver gang, der sendes en besked til psoc'en. Interrupt prioritetten vil for dette interrupt være høj i forhold til de andre interrupts på PlayerSideApp, da der ikke ønskes at andre interrupts på PSoC'en går ind og forstyrrer denne opdatering af bufferen.  

Udover at modtage status opdateringer modtager psoc'en også data omkring farver fra både playerside 1 og 2. Denne besked er 5 byte lang. Dette beskrives mere i dybden i grænsefladeafsnittet \ref{sec:RPi_Playerside_com}. Denne besked behandles også i funktionen  RPi\_IF\_handleData(), hvor et struct opdateres med farvekombinationen. Mere om dette struct beskrives i Cuplight\_IF Design afsnit \fullref{sec:cuplight_sw_design}. 

Udover at psoc'en modtager beskeder fra RPI'en(raspberry pi), så skal den også sende beskeder til RPI'en. Dette gøres  via en funktion i boundaryklassen kaldet sendCupStatus. Denne funktion tager en parameter af typen uint8, som er en byte, der beskriver cup status. For mere information refereres igen til grænseflade afsnittet i software arkitekturen \fullref{sec:RPi_Playerside_com}. Funktionen går starter med at resette readbufferen fra i2c slave enheden(Vi skal selv lave bufferen, som gjort ved writebufferen) ved at lægge 0xFF ind på alle pladser i bufferen. Cup status bliver herefter lagt over i bufferen, så RPI'en kan læse det. Herefter bliver funktionen  Efter dette skal interrupt benet trækkes lavt igen. Da RPI driveren reagerer på en falling edge, kan den godt nå, at registeres et interrupt på den tid det tager psoc'en at loade readbufferen. RPI driveren sørger nu for selv at læse fra bufferen. 






\end{document}