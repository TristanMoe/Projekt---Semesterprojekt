\documentclass[Softwaredesign/Softwaredesign_main.tex]{subfiles}
\begin{document}
\section{playerside boudary}
På playerside siden skulle, der på psoc laves en boundary klasse, der stod for modtagelse af i2c beskeder fra raspberry pi. Der er to former for beskeder, der skal sendes til psoc'en på playerside. Det ene er status opdateringer, som er en byte lange. Mere detaljeret beskrivelse kan ses i grænseflade afsnittet. Der bliver her brugt en i2c slave komponent i psoc creators komponent katalog. Denne komponent har en writebuffer, der selv opdatere efter hvert interrupt(der er en slaveInitReafbuffer funktion der tager et array af typen uint8, så det nu er dette array, der fungerer som bufferen). Der skal dog også læses fra denne buffer, når psoc'en modtager beskeden. Dette kan gøres på to forskellige måder. Den første måde er ved brug af polling og er den metode, der oftest bruges, hvis der ses i databladene. Dette kan dog i visse tilfælde ikke være optimalt, hvis programmet vil lave andet end blot at tjekke for i2c beskeder sendt. En anden mulighed er, at der læses fra writebufferen med det samme, når en besked bliver sendt. Dette kan lade sig gøre ved hjælp af interrupts. Som sagt så sker, der automatisk en opdatering af writebufferen ved brug af interrupts. Dette interrupt kan vi gå ind og gøre brug af ved hjælp af en callback metode I2C\_ISR\_EntryCallback(), som er fundet i i2c slave enhedens datasheet Her vil funktionen RPi\_IF\_handleData() håndterer det der nu står i writebufferen. Spørgsmålet er, hvilken en af tingene, der er bedst. Vi har valgt polling af den grund at mange af de andre boundary klasser(CupLight\_IF og CupSensor\_IF) på PSoC'en bruger interrupts, og da der alligevel vil være et uendeligt for-loop i programmet, så placeres funktionen RPi\_IF\_handleData() her, så de andre boundaries prioriteres over denne klasse, når der sker et interrupt. Der vil dog stadig være de interrupts, der høre til funktionen af i2c slave enheden på PSoC'en og som sørger for at opdaterer writebufferen efter hver gang der sendes en besked til psoc'en. interrupt prioritetten vil for dette interrupt være højt, da der ikke ønskes at andre interrupts på PSoC'en går ind og forstyrrer denne opdatering af bufferen.  

Udover at modtage status opdateringer modtager psoc'en også data omkring farver fra både playerside 1 og 2. Denne besked er 5 byte lang. Dette beskrives mere i dybden i grænsefladeafsnittet. Denne besked behandles også i funktionen  RPi\_IF\_handleData(), hvor et struct opdateres med farvekombinationen, Mere om dette struct beskrives i Cuplight\_IF Design dokumentet. 

Udover at psoc'en modtager beskeder fra rpi'en(raspberry pi), så skal den også sende beskeder til rpi'en. Dette gøres  via en funktion i boundaryklassen kaldet sendCupStatus. Denne funktion tager en parameter af typen uint8, som er en byte, der beskriver cup status. For mere information refereres igen til grænseflade afsnittet i software arkitekturen. Det første denne funktion gør at at skabe et interrupt på rpi'en. Dette gøres ved at trække et interrupt ben lavt, hvorved rpi'en får besked om, at der nu skal læses fra psoc'en, der bliver herefter gjort brug af readbufferen fra i2c slave enheden(Vi skal selv lave bufferen, som gjort ved writebufferen). Cup status bliver herefter lagt over i bufferen, så rpi'en kan læse det. Efter dette skal interrupt benet trækkes lavt igen. Da rpi driveren reagerer på en falling edge, kan den godt nå at registeres et interrupt på den tid det tager psoc'en at loade readbufferen. Rpi driveren sørger nu for selv at læse fra bufferen. 






\end{document}