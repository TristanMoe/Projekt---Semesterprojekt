\documentclass[Softwaredesign/Softwaredesign_main.tex]{subfiles}
\begin{document}
\section{Design af I2C-interruptDriver}\label{sec:I2C_interruptDriver_design_bilag}
\subsection{Kernalspace driver}
Userspace programmet RPiApp skal læse og skrive til og fra de tre filer /dev/Playerside1, /dev/Playerside2 og /dev/BallDispenser. Disse filer repræsentere de tre hardware enheder. Til dette laves der én driver. Denne driver skal kunne skrive til hver hardware enhed(PSoC for de to playersides og ballDipenser) vha. I2C protokollen. Der bliver brugt 3 interrupt linjer mellem RPi'en og de 3 hardware enheder, når hardware enhederne har noget information, de skal sende til RPi'en. 

Driveren skrives som et kernemodul og til inspiration benyttes øvelse 3 fra HAL og frem til øvelse 6. Den vigtigste del fra denne øvelse, er at lave en init og exit funktion. Dette kernemodul laves som en character driver. For at lave en character driver skal der til denne drivers være en open, release, read og write funktion, da vi senere lavede driveren om til en platform driver blev der tilføjet en probe og remove funktion. Da der bliver brugt interrupt er der også en interrupt vektor.

\subsubsection{I2C}
Da driveren skal kommunikere vha. I2C protokollen benyttes den dedikerede I2C hardware på RPi. Til at kommunikere med dette hardware benyttes biblioteket \textbf{i2c.h}. Biblioteket bygger på forskellige strukturer. \textbf{i2c\_adapter} og\textbf{ i2c\_client} er de to vigtigste der benyttes. 
\textbf{i2c\_adapter} repræsenterer den I2C hardware på RPi som benyttes. Der kan være flere busser på et system og på RPi er der 2. Og der skal derfor benyttes et \textbf{i2c\_adapter} som bruger denne rigtige bus. 
\textbf{i2c\_client} repræsenterer hver enhed som er forbundet til I2C bussen. Den vigtigste attribut i denne struct er addr attributten. Denne attribut beskriver hvilken I2C adresse hver enhed har. En anden vigtig attribut, er hvilken \textbf{i2c\_adapter} som enheden er forbundet til.
I denne driver skal der være én \textbf{i2c\_adapter} og tre \textbf{i2c\_client}'s. En for side1, side2 og BallDispenser. \\
Der kan oprettes \textbf{i2c\_client}'er på en del forskellige måder. Nogle er mere "automatiske" end andre. Til denne denne driver benyttes den mest direkte og simple måde, der kan oprettes en \textbf{i2c\_client} vha. funktionen \textbf{i2c\_new\_device}. Denne funktion tager to argumenter, den ene er den \textbf{i2c\_adapter} der bruges og så et struct \textbf{i2c\_board\_info}. Dette struct indeholder mange informationer om enheden. I denne driver udelades mange af disse informationer og der benyttes kun information om adressen og et navn på denne enhed.\\
For at skrive til en I2C enhed bruges funktionen \textbf{i2c\_master\_send}. For at læse fra en I2C enhed bruges funktionen \textbf{i2c\_master\_recv}. Begge funktioner har som parameter den\textbf{ i2c\_client} der skal skrives til, den buffer der skal skrives til eller læses til og antallet af bytes der skal skrives eller læses. Begge funktioner returnerer hvor mange bytes, der er blevet læst/skrevet.

Det beskrives nu hvordan driveren skal håndtere flere enheder. Der oprettes en node/fil til hver enhed med hver deres minor nummer.
Der er i driveren lavet et struct \textbf{i2c\_interrupt\_device}. Dette bruges til at beskrive de forskellige I2C enheder. Det indholder en \textbf{i2c\_client}, \textbf{i2c\_board\_info} og et minor nummer. Der oprettes tre "objekter" af denne struct, en til hver endhed. Når der åbnes for en fil/node (vha open funktionen) sættes den private data for den fil til at være det givne devices \textbf{i2c\_interrupt\_device}. Dette gør at når der læses og skrives til den samme fil, så er det allerede tilgængelig hvilken \textbf{i2c\_client} der skal bruges.

\subsubsection{Platform driver}
Vi startede ud med at lave en driver, hvor der ikke ville kunne ændres på de gpio'er der bruges efter at driveren er lavet. Dette ændrede sig efter at der i øvelse 6 blev lært om platform drivere. De gpio'er vi brugte i driveren kunne nu ændres ved bare at ændre i device tree, hvilket man gør ved hjælp af en dts fil, der nu også laves til driveren(dts filen skal indsættes i RPI'ens device tree. Man laver normalt ikke en platform driver, når det er interface til en bus, da man istedet laver en bus driver. De ligner meget hinanden,  men som forskel initieres bus driveren i dts filen, hvor det her bliver gjort i probe funktionen. Gruppen kunne have valgt, at lave dette om til en I2C bus driver istedet, men valgte at lade være, da det blev lært for sent i projektet. Vi valgte dog ikke at udvide denne driver mere. I en platform driver flyttes meget af det man normalt ville have lavet i init funktionen til probe fuktionen. Denne kaldes i tilfældet, hvor både dts overlay filen er indsat i kernel source tree. Det er her man anmoder om de fleste resurser, såsom den bus vi skal bruge ved funktionen \textbf{get\_adapter()} og have oprettet de klienter der skal tilføjes bussen med funktionen \textbf{i2c\_new\_device}. Der skal også anmodes om de gpio'er, som bliver fundet fra device tree, sammen med de interrupt linjer, der bliver brugt. Udover dette skal nder oprettes med hvert sit minor nummer. Dette bruges funktionen create\_device til. Der vil kun oprettes noder svarende til antallet af gpio'er specificeret i dts filen. På denne måde undgår vi at for mange noder oprettes, hvis de ikke bruges. Man kan sige at vores system ikke fungerer uden alle  noder(begge playersides og balldispenser), men ved en mulig udvidning af systemet er det en god funktion at have. Disse resurser frigives i remove funktionen, når modulet fjernes fra kernel source tree eller dts filen fjernes fra device tree. Det vil også være her de forskellige noder til de 3 hardware enheder vil blive oprettet.
Init sørger for at registerer driveren som char driver oprette en klasse i /sys/folderen ved hjælp af funktionerne textbf{class\_create} og textbf{platform\_driver\_register}. Exit vil herimod slette klassen i /sys/folderen og afregisterer driveren, som char driver og platform driver.

\subsubsection{Interrupts}
For at rpi'en skal kunne læse fra hardware enhederne i systemet(psocs for playersides og balldispenser) skal den hardware enhed, der har noget den vil have læst af rpi'en, skabe et interrupt. Interrupts bliver initieret i probe funktionen 
 En af design mulighederne var, at lave en samlet interruptlinje for de tre hardware enheder. Det var også det første der blev gjort driveren blev lavet og testet med denne funktion i første omgang. Det er ikke den mest optimale måde at gøre det på denne måde og den er lidt mere indviklet end at lave en interrupt linje for hver hardware enhed. Vi endte derfor med at skifte til at bruge 3 interrupt linjer, der alle er falling edge triggered. På denne måde slipper RPi driveren for at spørge hver enkelt hardware enhed om, hvilken af dem der skabte interruptet og herefter læse fra den enhed, der skabte interruptet. Det eneste RPI driverens interrupt vektor skal gøre er, at starte i2c overførslen fra den hardware enhed, der skabte interruptet. Den måde interrupt linjerne bliver sat op på starter i probe funktion. I denne funktion vil der initialiseres en wait queue for hver minor nummer(eller node), som vi senere vil bruge i  read funktionen for at få den til at sove. Gpio'erne specificeret i device tree vil også blive fordelt på de forskellige noder, der skal laves(de hører til forskellige minor numre). Interrupt linjerne for de forskellige gpio'er skal også findes, hvorefter en interrupt vektor vil blive anmodet om for hver node. I denne anmodning skal vi på en eller anden måde kunne give information til vores interrupt vektorer om hvilke node, der er hører til de forskellige interrupts. Dette gøres ved hjælp af structet i2c\_interrupt\_device, som der ialt er 3 af(en for hver hardware enhed). I dette struct er minor nummeret specificeret sammen med en masse anden information omkring de forskellige hardware enheder. Dette er specielt vigtig, da vi i interrupt vektoren skal vide, hvilken readfunktion vi skal vække og hvilket flag, der skal sættes. flagets funktion beskrives nednfor, hvor readfunktionen beskrives
 \subsubsection{Read og write funktionen}
 Driverens read funktion skal først og fremmest finde ud af hvilken minor nummer, den hører til og derved hvilken hardwareenhed den har forbindelse til. Den vil herefter lægge sig til at sove, hvor den kun kan vækkes af et kald fra interrupt vektoren, der hører til noden. Her bruges flaget flag i structet i2c\_interrupt\_device, som conditional i funktionen wait\_event\_interruptible, hvor det vil blive i tilfældet, hvor der sker et interrupt. Efter dette gjort så vil funktionen \textbf{i2c\_master\_recv()} kaldes, hvor en buffer vil modtage data sendt til RPI og ved hjælp af denne kopiere det til brugeren.
 
 Driverens write funktion skal stort set bare skrive til den korrekte \textbf{i2c\_client} vha. \textbf{i2c\_master\_send}, efter at dataen , der skal sendes er kopieret til kernelspace, og hardwareenheden, der skal sendes noget ud til er hentet fra private\_data.

\end{document}